//--------------------------------------------------------------------------//
// Copyright 2023-2025 Chocolate Dinosaur Ltd. All rights reserved.         //
// For full documentation visit https://www.chocolatedinosaur.com           //
//--------------------------------------------------------------------------//

#if UIFX_TMPRO

using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using UnityInternal = UnityEngine.Internal;
using TMPro;

namespace ChocDino.UIFX
{
	/// <summary>
	/// Takes the geometry generated by TextMeshPro and modifies the vertices by applying any Components that inherit IMeshModifier.
	/// Supports sprites (submeshes).
	/// Tested with TextMeshPro v2.1.6 (Unity 2019), v2.2.0-preview.3 (Unity 2019), v3.0.8 (Unity 2020), 3.2.0-pre.9 (Unity 2022)
	/// Needs optimising of temporary Mesh caching, using too many component channels in VertexHelper
	/// </summary>
	[ExecuteAlways]
	[RequireComponent(typeof(TextMeshProUGUI))]
	[HelpURL("https://www.chocdino.com/products/unity-assets/")]
	[AddComponentMenu("UI/Chocolate Dinosaur UIFX/Effects/UIFX - TextMeshPro Mesh Modifier", 100)]
	public class TextMeshProMeshModifier : UIBehaviour
	{
		private Graphic _graphic;
		private Graphic GraphicComponent { get { if (_graphic == null) _graphic = GetComponent<Graphic>(); return _graphic; } }

		private TextMeshProUGUI _textMeshPro;

		private List<IMeshModifier> _modifiers = new List<IMeshModifier>(8);
		private List<TMP_SubMeshUI> _subMeshes = new List<TMP_SubMeshUI>(8);

		private Mesh _processMesh;

		[UnityInternal.ExcludeFromDocs]
		protected override void Awake()
		{
			_textMeshPro = GetComponent<TextMeshProUGUI>();
			base.Awake();
		}

		[UnityInternal.ExcludeFromDocs]
		protected override void OnEnable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Add(OnTextGeomeryRebuilt);

			// This forces TMP to re-render
			_textMeshPro.SetAllDirty();

			base.OnEnable();
		}

		[UnityInternal.ExcludeFromDocs]
		protected override void OnDisable()
		{
			TMPro_EventManager.TEXT_CHANGED_EVENT.Remove(OnTextGeomeryRebuilt);
			
			// This forces TMP to re-render
			_textMeshPro.SetAllDirty();

			base.OnDisable();
		}

		private void OnTextGeomeryRebuilt(Object obj)
		{
			if (obj == _textMeshPro)
			{
				ApplyMeshModifiers();

				// For some reason we need to set things dirty here so that future changes to the filters will cause rerendering
				GraphicComponent.SetAllDirty();
			}
		}

		private void ApplyMeshModifiers()
		{
			// TODO: Ideally we'd like to have an option to combine the mesh+submeshes into a single mesh..
			// but this would be more expensive and quite complicated and wasteful code due to having to convert
			// between Mesh and VertexHelper and combining meshes.
			GetComponents<IMeshModifier>(_modifiers);
			if (_modifiers.Count > 0)
			{
				// Modify main mesh
				ModifyMesh(_modifiers, _textMeshPro.mesh, _textMeshPro.canvasRenderer);

				// Modify submeshes
				if (_textMeshPro.textInfo.materialCount > 1)
				{
					GetComponentsInChildren<TMP_SubMeshUI>(false, _subMeshes);
					for (int i = 1; i < _textMeshPro.textInfo.materialCount; i++)
					{
						TMP_SubMeshUI subMesh = _subMeshes[i - 1];
						TMP_MeshInfo mi = _textMeshPro.textInfo.meshInfo[i];
						ModifyMesh(_modifiers, mi.mesh, subMesh.canvasRenderer);
					}
				}
			}
		}

		private void ModifyMesh(List<IMeshModifier> modifiers, Mesh mesh, CanvasRenderer cr)
		{
			// Fix issue when converting Mesh to VertexHelper where for TextMeshPro the uv3 and uv4 have length zero
			// Then calling PopulateUIVertex() will have out of range exception as it expects all component arrays to be equal
			if (mesh.uv3.Length != mesh.uv2.Length)
			{
				mesh.uv3 = mesh.uv2;
			}
			if (mesh.uv4.Length != mesh.uv2.Length)
			{
				mesh.uv4 = mesh.uv2;
			}

			VertexHelper vh = new VertexHelper(mesh);

			for (var j = 0; j < modifiers.Count; j++)
			{
				modifiers[j].ModifyMesh(vh);
			}

			if (!_processMesh) { _processMesh = new Mesh(); }
			vh.FillMesh(_processMesh);
			cr.SetMesh(_processMesh);

			vh.Dispose();
		}
	}
}
#endif